import{useRequest as i}from"./index.VGyafNOA.js";import{d as k,i as l,v as n,g as e}from"./vi.JYQecGiw.CsLlcVZs.js";import{P as r}from"./framework.igcgEEdr.js";import"./commonjsHelpers.BosuxZz1.js";import"./vite-browser-external_commonjs-proxy.BC9WSf1a.js";k("useRequest",()=>{l("应该返回正确的响应式属性",()=>{const t=n.fn().mockResolvedValue({data:"test"}),{data:o,isLoading:a,isFinished:s,error:c,execute:m}=i(t,{immediate:!1});e(o.value).toBeUndefined(),e(a.value).toBe(!1),e(s.value).toBe(!1),e(c.value).toBeUndefined(),e(typeof m).toBe("function")}),l("immediate 为 true 时应该立即执行请求",async()=>{const t=n.fn().mockResolvedValue({data:"test"}),{isLoading:o}=i(t,{immediate:!0});e(t).toHaveBeenCalled(),e(o.value).toBe(!0),await new Promise(a=>setTimeout(a,10)),e(o.value).toBe(!1)}),l("immediate 为 false 时不应该立即执行请求",()=>{const t=n.fn().mockResolvedValue({data:"test"});i(t,{immediate:!1}),e(t).not.toHaveBeenCalled()}),l("应该支持手动执行请求",async()=>{const t=n.fn().mockResolvedValue({data:"test"}),{execute:o,data:a,isLoading:s,isFinished:c}=i(t,{immediate:!1});e(t).not.toHaveBeenCalled();const m=o();e(s.value).toBe(!0),e(c.value).toBe(!1),await m,await r(),e(t).toHaveBeenCalled(),e(a.value).toEqual({data:"test"}),e(s.value).toBe(!1),e(c.value).toBe(!0)}),l("应该支持传递参数执行请求",async()=>{const t=n.fn().mockResolvedValue({data:"test"}),{execute:o}=i(t,{immediate:!1});await o("param1","param2"),e(t).toHaveBeenCalledWith("param1","param2")}),l("应该在请求成功时调用 onSuccess",async()=>{const t={data:"test"},o=n.fn().mockResolvedValue(t),a=n.fn(),{execute:s}=i(o,{immediate:!1,onSuccess:a});await s(),e(a).toHaveBeenCalledWith(t)}),l("应该正确处理请求错误",async()=>{const t=new Error("Request failed"),o=n.fn().mockRejectedValue(t),{execute:a,error:s,isLoading:c,isFinished:m}=i(o,{immediate:!1});try{await a()}catch(u){e(u).toBe(t)}e(s.value).toBe(t),e(c.value).toBe(!1),e(m.value).toBe(!0)}),l("应该在请求失败时调用 onError",async()=>{const t=new Error("Request failed"),o=n.fn().mockRejectedValue(t),a=n.fn(),{execute:s}=i(o,{immediate:!1,onError:a});try{await s()}catch(c){console.warn(c)}e(a).toHaveBeenCalledWith(t)}),l("应该支持多次执行请求",async()=>{let t=0;const o=n.fn().mockImplementation(async()=>(t++,{count:t})),{execute:a,data:s}=i(o,{immediate:!1});await a(),e(s.value).toEqual({count:1}),await a(),e(s.value).toEqual({count:2}),await a(),e(s.value).toEqual({count:3}),e(o).toHaveBeenCalledTimes(3)}),l("应该正确管理 loading 状态",async()=>{const t=n.fn().mockImplementation(()=>new Promise(m=>setTimeout(()=>m({data:"test"}),100))),{execute:o,isLoading:a,isFinished:s}=i(t,{immediate:!1});e(a.value).toBe(!1),e(s.value).toBe(!1);const c=o();e(a.value).toBe(!0),e(s.value).toBe(!1),await c,await r(),e(a.value).toBe(!1),e(s.value).toBe(!0)}),l("每次执行前应该清除之前的错误",async()=>{const t=new Error("First error");let o=!0;const a=n.fn().mockImplementation(async()=>{if(o)throw t;return{data:"success"}}),{execute:s,error:c,data:m}=i(a,{immediate:!1});try{await s()}catch(u){console.warn(u)}e(c.value).toBe(t),e(m.value).toBeUndefined(),o=!1,await s(),e(c.value).toBeUndefined(),e(m.value).toEqual({data:"success"})}),l("execute 应该返回 Promise",async()=>{const t={data:"test"},o=n.fn().mockResolvedValue(t),{execute:a}=i(o,{immediate:!1}),s=await a();e(s).toEqual(t)}),l("execute 应该在失败时 reject Promise",async()=>{const t=new Error("Request failed"),o=n.fn().mockRejectedValue(t),{execute:a}=i(o,{immediate:!1});await e(a()).rejects.toThrow("Request failed")}),l("应该正确处理并发请求",async()=>{let t=0;const o=n.fn().mockImplementation(async v=>(t++,await new Promise(B=>setTimeout(B,v)),{count:t})),{execute:a}=i(o,{immediate:!1}),s=a(50),c=a(30),m=a(10),[u,d,f]=await Promise.all([s,c,m]);e(u.count).toBeDefined(),e(d.count).toBeDefined(),e(f.count).toBeDefined(),e(o).toHaveBeenCalledTimes(3)}),l("应该正确推断数据类型",async()=>{var s,c;const t=n.fn().mockResolvedValue({id:1,name:"Test User"}),{data:o,execute:a}=i(t,{immediate:!1});await a(),e((s=o.value)==null?void 0:s.id).toBe(1),e((c=o.value)==null?void 0:c.name).toBe("Test User")})});
